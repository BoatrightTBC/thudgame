<!DOCTYPE HTML>
<html>
  <head>
  </head>
  <body>
    <div id="gameboard"></div>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/kineticjs/5.0.6/kinetic.min.js"></script>
    <script defer="defer">
      var gameboard_px = 600;
      var gameboard_squares = 15;
      var square_size = gameboard_px/gameboard_squares;

      var stage = new Kinetic.Stage({
        container: 'gameboard',
        width: gameboard_px,
        height: gameboard_px
      });
      var grid = new Kinetic.Layer();
      var piece_layer = new Kinetic.Layer();

      stage.add(grid);
      stage.add(piece_layer);

      var images = {
        board: new Image(),
        thudstone: new Image(),
        troll: new Image(),
        dwarf: new Image()
      }

      images['board'].onload = function() {
        var b = new Kinetic.Image({
          x: 0,
          y: 0,
          image: images['board'],
          width: gameboard_px,
          height: gameboard_px
        });
        grid.add(b);
        stage.draw();
      };

      images['board'].src = 'tb.gif';
      images['thudstone'].src = 'thudstone.gif';
      images['troll'].src = 'rook.gif';
      images['dwarf'].src = 'pawn.gif';

      var game_pieces = {};

      PIECES = {
          d: 'dwarf',
          t: 'troll',
          r: 'thudstone'
        }

      TO_NUMBERS = {'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5,
                    'F': 6, 'G': 7, 'H': 8, 'J': 9, 'K': 10,
                    'L': 11,'M': 12,'N': 13,'O': 14,'P': 15 }
      TO_LETTERS = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E',
                    6: 'F', 7: 'G', 8: 'H', 9: 'J', 10:'K',
                    11:'L', 12:'M', 13:'N', 14:'O', 15:'P' }

      CLASSIC_POSITIONS = 'dF1,dG1,dJ1,dK1,dE2,dL2,dD3,dM3,dC4,dN4,dB5,dO5,dA6,dP6,dA7,dP7,dA9,dP9,dA10,dP10,dB11,dO11,dC12,dN12,dD13,dM13,dE14,dL14,dF15,dG15,dJ15,dK15,TG7,TH7,TJ7,TG8,TJ8,TG9,TH9,TJ9,RH8'

      function start_classic() {
        pieces = CLASSIC_POSITIONS.split(',');

        for (var p in pieces)
          materialize_piece(pieces[p].slice(1), PIECES[pieces[p][0].toLowerCase()]);
      }

      function materialize_piece(position, side) {
        var coords = notation_to_coords(position);

        var piece = new Kinetic.Image({
          x: coords.x,
          y: coords.y,
          image: images[side],
          width: square_size,
          height: square_size,
          team: side,
          draggable: (side == 'thudstone' ? false : true),
        });

        piece_layer.add(piece);
        stage.draw();

        piece.on('dragstart', function(e) {
          start_coords = {
            x: e.target.x(),
            y: e.target.y()
          }
          console.log(side + ' picked up from ' + coords_to_notation(start_coords));
        });
        
        piece.on('dragend', function(e) {
          end_coords = {
            x: e.evt.layerX,
            y: e.evt.layerY,
          }

          move_piece(position, coords_to_notation(end_coords));
          console.log(side + ' dropped on ' + coords_to_notation(end_coords));
        });

        game_pieces[position] = piece;
      }

      function move_piece(starting_position, ending_position) {
        var coords = notation_to_coords(ending_position);

        var tween = new Kinetic.Tween({
          node: game_pieces[starting_position],
          duration: 1,
          x: coords.x,
          y: coords.y
        });
        game_pieces[ending_position] = game_pieces[starting_position];
        tween.play();
      }

      function remove_piece(position) {
        game_pieces[position].remove();
        delete game_pieces[position];
        stage.draw();
      }

      function make_capture(starting_position, ending_position, captured_positions) {
        var start = game_pieces[starting_position];
        var end = game_pieces[ending_position];

        move_piece(starting_position, ending_position);

        for (var p in captured_positions) 
          remove_piece(captured_positions[p])
      }

      function notation_to_coords(position) {
        return {
          x: (TO_NUMBERS[position[0]] - 1) * square_size,
          y: (parseInt(position.slice(1)) - 1) * square_size
        }
      }

      function coords_to_notation(coords) {
        file = TO_LETTERS[Math.floor(coords.x / square_size) + 1]
        rank = Math.floor(coords.y / square_size) + 1;

        return file + rank.toString();
      }

      stage.on('click', function() {
        console.log( coords_to_notation(stage.getPointerPosition()) )
      })

    </script>
  </body>
</html>